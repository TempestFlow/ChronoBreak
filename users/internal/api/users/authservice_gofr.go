// Code generated by gofr.dev/cli/gofr. DO NOT EDIT.
// versions:
// 	gofr-cli v0.6.0
// 	gofr.dev v1.37.0
// 	source: users.proto

package v1

import (
	"context"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/container"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	healthpb "google.golang.org/grpc/health/grpc_health_v1"
)

// NewAuthServiceGoFrServer creates a new instance of AuthServiceGoFrServer
func NewAuthServiceGoFrServer() *AuthServiceGoFrServer {
	return &AuthServiceGoFrServer{
		health: getOrCreateHealthServer(), // Initialize the health server
	}
}

// AuthServiceServerWithGofr is the interface for the server implementation
type AuthServiceServerWithGofr interface {
	Login(*gofr.Context) (any, error)
	Signup(*gofr.Context) (any, error)
	RefreshToken(*gofr.Context) (any, error)
	GetUser(*gofr.Context) (any, error)
	GetUserByID(*gofr.Context) (any, error)
	Logout(*gofr.Context) (any, error)
	Validate(*gofr.Context) (any, error)
}

// AuthServiceServerWrapper wraps the server and handles request and response logic
type AuthServiceServerWrapper struct {
	AuthServiceServer
	*healthServer
	Container *container.Container
	server    AuthServiceServerWithGofr
}

//
// Login wraps the method and handles its execution
func (h *AuthServiceServerWrapper) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
	gctx := h.getGofrContext(ctx, &LoginRequestWrapper{ctx: ctx, LoginRequest: req})

	res, err := h.server.Login(gctx)
	if err != nil {
		return nil, err
	}

	resp, ok := res.(*LoginResponse)
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}
// Signup wraps the method and handles its execution
func (h *AuthServiceServerWrapper) Signup(ctx context.Context, req *SignupRequest) (*SignupResponse, error) {
	gctx := h.getGofrContext(ctx, &SignupRequestWrapper{ctx: ctx, SignupRequest: req})

	res, err := h.server.Signup(gctx)
	if err != nil {
		return nil, err
	}

	resp, ok := res.(*SignupResponse)
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}
// RefreshToken wraps the method and handles its execution
func (h *AuthServiceServerWrapper) RefreshToken(ctx context.Context, req *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	gctx := h.getGofrContext(ctx, &RefreshTokenRequestWrapper{ctx: ctx, RefreshTokenRequest: req})

	res, err := h.server.RefreshToken(gctx)
	if err != nil {
		return nil, err
	}

	resp, ok := res.(*RefreshTokenResponse)
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}
// GetUser wraps the method and handles its execution
func (h *AuthServiceServerWrapper) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {
	gctx := h.getGofrContext(ctx, &GetUserRequestWrapper{ctx: ctx, GetUserRequest: req})

	res, err := h.server.GetUser(gctx)
	if err != nil {
		return nil, err
	}

	resp, ok := res.(*GetUserResponse)
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}
// GetUserByID wraps the method and handles its execution
func (h *AuthServiceServerWrapper) GetUserByID(ctx context.Context, req *GetUserByIDRequest) (*GetUserByIDResponse, error) {
	gctx := h.getGofrContext(ctx, &GetUserByIDRequestWrapper{ctx: ctx, GetUserByIDRequest: req})

	res, err := h.server.GetUserByID(gctx)
	if err != nil {
		return nil, err
	}

	resp, ok := res.(*GetUserByIDResponse)
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}
// Logout wraps the method and handles its execution
func (h *AuthServiceServerWrapper) Logout(ctx context.Context, req *LogoutRequest) (*LogoutResponse, error) {
	gctx := h.getGofrContext(ctx, &LogoutRequestWrapper{ctx: ctx, LogoutRequest: req})

	res, err := h.server.Logout(gctx)
	if err != nil {
		return nil, err
	}

	resp, ok := res.(*LogoutResponse)
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}
// Validate wraps the method and handles its execution
func (h *AuthServiceServerWrapper) Validate(ctx context.Context, req *ValidateRequest) (*ValidateResponse, error) {
	gctx := h.getGofrContext(ctx, &ValidateRequestWrapper{ctx: ctx, ValidateRequest: req})

	res, err := h.server.Validate(gctx)
	if err != nil {
		return nil, err
	}

	resp, ok := res.(*ValidateResponse)
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}

// mustEmbedUnimplementedAuthServiceServer ensures that the server implements all required methods
func (h *AuthServiceServerWrapper) mustEmbedUnimplementedAuthServiceServer() {}

// RegisterAuthServiceServerWithGofr registers the server with the application
func RegisterAuthServiceServerWithGofr(app *gofr.App, srv AuthServiceServerWithGofr) {
	registerServerWithGofr(app, srv, func(s grpc.ServiceRegistrar, srv any) {
		wrapper := &AuthServiceServerWrapper{server: srv.(AuthServiceServerWithGofr), healthServer: getOrCreateHealthServer()}
		RegisterAuthServiceServer(s, wrapper)
		wrapper.Server.SetServingStatus("AuthService", healthpb.HealthCheckResponse_SERVING)
	})
}

// getGofrContext extracts the GoFr context from the original context
func (h *AuthServiceServerWrapper) getGofrContext(ctx context.Context, req gofr.Request) *gofr.Context {
	return &gofr.Context{
		Context:   ctx,
		Container: h.Container,
		Request:   req,
	}
}
